var documenterSearchIndex = {"docs":
[{"location":"api/#API-Reference","page":"API Reference","title":"API Reference","text":"","category":"section"},{"location":"api/#Core-Meshing-and-Types","page":"API Reference","title":"Core Meshing & Types","text":"The primary interface for generating meshes and handling the resulting data structures.","category":"section"},{"location":"api/#Distance-Functions:-Basic-Shapes","page":"API Reference","title":"Distance Functions: Basic Shapes","text":"Pre-defined signed distance functions for common primitives in 2D and 3D.","category":"section"},{"location":"api/#Distance-Functions:-Polygons-and-Lines","page":"API Reference","title":"Distance Functions: Polygons & Lines","text":"Utilities for working with polygonal boundaries and line segments.","category":"section"},{"location":"api/#Distance-Functions:-Boolean-Operations-(CSG)","page":"API Reference","title":"Distance Functions: Boolean Operations (CSG)","text":"Constructive Solid Geometry operations to combine multiple distance functions.","category":"section"},{"location":"api/#Distance-Functions:-Special-Functions","page":"API Reference","title":"Distance Functions: Special Functions","text":"Helper functions for element sizing and specific test cases (like airfoils).","category":"section"},{"location":"api/#Mesh-utilities:-Size-functions","page":"API Reference","title":"Mesh utilities: Size functions","text":"","category":"section"},{"location":"api/#Mesh-utilities:-General","page":"API Reference","title":"Mesh utilities: General","text":"","category":"section"},{"location":"api/#DistMesh.distmesh2d","page":"API Reference","title":"DistMesh.distmesh2d","text":"distmesh2d(dfcn, hfcn, h0, bbox, pfix=[]; kwargs...) -> (p, t)\n\nGenerate a 2D unstructured triangular mesh using a signed distance function.\n\nThis function implements the DistMesh algorithm (Persson/Strang), which treats the mesh generation  as a physical equilibrium problem. A system of truss bars (edges) is relaxed until the force  equilibrium is reached, constrained by the signed distance function dfcn to stay within the domain.\n\nArguments\n\ndfcn::Function: Signed distance function d(p). Returns negative values inside the region, positive outside. The input p is a 2-element coordinate vector (e.g., Vector, Tuple, or SVector).\nhfcn::Function: Element size function h(p). Returns target edge length at point p.\nh0::Real: Initial nominal edge length (scaling factor for hfcn).\nbbox: Bounding box tuple ((xmin, ymin), (xmax, ymax)) defining the initial grid generation area.\npfix::Vector: (Optional) List of fixed node positions that must be part of the mesh (e.g., corners).\n\nKeywords\n\nplotting::Bool = false: Enable live visualization of the relaxation process (Plots or GLMakie).\nmaxiter::Int = 10_000: Maximum number of relaxation iterations.\nSeveral other parameters that are rarely modified\n\nReturns\n\np::Vector{Point2d}: The node positions.\nt::Vector{Index3}: The triangle connectivity indices.\n\nExamples\n\nUniform Mesh on a Unit Circle\n\nusing DistMesh\n\nfd(p) = sqrt(sum(p.^2)) - 1  # or dcircle(p) - unit circle geometry\nfh(p) = 1.0                  # or huniform(p) - uniform size function\nhmin  = 0.2                  # initial edge lengths\nbbox  = ((-1,-1), (1,1))     # bounding box for unit circle\n\nmsh = distmesh2d(fd, fh, hmin, bbox)\n\n# Optionally, the mesh can be visualized using various plotting packages:\nusing GLMakie # or Plots, or CairoMakie\nplot(msh)\n\nRectangle with Circular Hole (Refined at Boundary)\n\nusing DistMesh\nhmin = 0.05\nfd(p) = ddiff(drectangle(p, -1, 1, -1, 1), dcircle(p, r=0.5))\nfh(p) = hmin + 0.3*dcircle(p, r=0.5)\nmsh = distmesh2d(fd, fh, hmin, ((-1,-1), (1,1)), ((-1,-1), (-1,1), (1,-1), (1,1))) \n\nPolygon\n\nusing DistMesh\npv = [(-0.4, -0.5), (0.4, -0.2), (0.4, -0.7), (1.5, -0.4),\n      (0.9, 0.1), (1.6, 0.8), (0.5, 0.5), (0.2, 1.0),\n      (0.1, 0.4), (-0.7, 0.7), (-0.4, -0.5)]\nfd(p) = dpoly(p, pv)\nbbox = ((-1,-1), (2,1))\nh0 = 0.15\nmsh = distmesh2d(fd, huniform, h0, bbox, pv)\n\nEllipse\n\nusing DistMesh\nfd(p) = (p[1]/2)^2 + (p[2]/1)^2 - 1\nbbox = ((-2,-1), (2,1))\nmsh = distmesh2d(fd, huniform, 0.2, bbox)\n\nSquare, with size function point and line sources\n\nusing DistMesh\nfd(p) = drectangle(p, 0, 1, 0, 1)\nfh(p) = min(min(0.01 + 0.3*abs(dcircle(p, r=0)),\n                0.025 + 0.3*abs(dpoly(p, [(0.3,0.7), (0.7,0.5)]))),\n            0.15)\nmsh = distmesh2d(fd, fh, 0.01, ((0,0), (1,1)), ((0,0), (1,0), (0,1), (1,1)))\n\nNACA0012 airfoil\n\nSee examples/002-naca_airfoil.jl\n\n\n\n\n\n","category":"function"},{"location":"api/#DistMesh.DMesh","page":"API Reference","title":"DistMesh.DMesh","text":"DMesh{D, T, N, I}\n\nA lightweight container for mesh data.\n\nD: Spatial dimension (e.g., 2 for 2D coordinates).\nT: Floating point type for coordinates (e.g., Float64).\nN: Number of vertices per element (e.g., 3 for triangles).\nI: Integer type for indices (e.g., Int, Int32).\n\n\n\n\n\n","category":"type"},{"location":"api/#DistMesh.as_arrays","page":"API Reference","title":"DistMesh.as_arrays","text":"p_view, t_view = as_arrays(m::DMesh)\n\nReturn zero-copy views of the mesh nodes and elements.\n\nNote: The shape is (D x NumPoints) and (N x NumElements).  This corresponds to Julia's column-major memory layout (columns are points). Modifying these arrays will modify the underlying DMesh.\n\n\n\n\n\n","category":"function"},{"location":"api/#DistMesh.dcircle","page":"API Reference","title":"DistMesh.dcircle","text":"dcircle(p; c=(0, 0), r=1.0)\n\nSigned distance function for a 2D circle.  Wrapper around dhypersphere that enforces 2D inputs.\n\n\n\n\n\n","category":"function"},{"location":"api/#DistMesh.drectangle","page":"API Reference","title":"DistMesh.drectangle","text":"drectangle(p, x1, x2, y1, y2)\n\nSigned distance function for a 2D axis-aligned rectangle. Returns negative values inside the region [x1, x2] × [y1, y2].\n\n\n\n\n\n","category":"function"},{"location":"api/#DistMesh.dhypersphere","page":"API Reference","title":"DistMesh.dhypersphere","text":"dhypersphere(p, c, r)\n\nSigned distance function for a hypersphere of radius r centered at c. Works for any dimension, provided p and c have matching lengths.\n\n\n\n\n\n","category":"function"},{"location":"api/#DistMesh.dsphere","page":"API Reference","title":"DistMesh.dsphere","text":"dsphere(p; c=(0, 0, 0), r=1.0)\n\nSigned distance function for a 3D sphere. Wrapper around dhypersphere that enforces 3D inputs.\n\n\n\n\n\n","category":"function"},{"location":"api/#DistMesh.dblock","page":"API Reference","title":"DistMesh.dblock","text":"dblock(p, x1, x2, y1, y2, z1, z2)\n\nSigned distance function for a 3D axis-aligned block (cuboid). Returns negative values inside the region [x1, x2] × [y1, y2] × [z1, z2].\n\n\n\n\n\n","category":"function"},{"location":"api/#DistMesh.dpoly","page":"API Reference","title":"DistMesh.dpoly","text":"dpoly(p, pv)\n\nSigned distance function for a polygon defined by vertices pv. Note: pv must be a closed loop (i.e., pv[end] == pv[1]). Returns negative values inside, positive outside.\n\n\n\n\n\n","category":"function"},{"location":"api/#DistMesh.dline","page":"API Reference","title":"DistMesh.dline","text":"dline(p, p1, p2)\n\nDistance from point p to the finite line segment defined by endpoints p1 and p2. Returns the Euclidean distance (always non-negative).\n\n\n\n\n\n","category":"function"},{"location":"api/#DistMesh.inpolygon","page":"API Reference","title":"DistMesh.inpolygon","text":"inpolygon(p, pv)\n\nPoint-in-polygon test using the Ray Casting algorithm. Returns true if p is inside the polygon defined by vertices pv.\n\n\n\n\n\n","category":"function"},{"location":"api/#DistMesh.ddiff","page":"API Reference","title":"DistMesh.ddiff","text":"ddiff(d1, d2)\n\nDifference of two regions (Region 1 minus Region 2). d1 and d2 are signed distances.\n\n\n\n\n\n","category":"function"},{"location":"api/#DistMesh.dunion","page":"API Reference","title":"DistMesh.dunion","text":"dunion(d1, d2)\n\nUnion of two regions. d1 and d2 are signed distances.\n\n\n\n\n\n","category":"function"},{"location":"api/#DistMesh.dintersect","page":"API Reference","title":"DistMesh.dintersect","text":"dintersect(d1, d2)\n\nIntersection of two regions. d1 and d2 are signed distances.\n\n\n\n\n\n","category":"function"},{"location":"api/#DistMesh.dnaca","page":"API Reference","title":"DistMesh.dnaca","text":"dnaca(p)\n\nImplicit level-set function for a NACA 0012 airfoil. Zero contour defines the airfoil boundary.\n\n\n\n\n\n","category":"function"},{"location":"api/#DistMesh.huniform","page":"API Reference","title":"DistMesh.huniform","text":"huniform(p)\n\nReturns 1.0. Default sizing function for uniform meshes.\n\n\n\n\n\n","category":"function"},{"location":"api/#DistMesh.element_volumes","page":"API Reference","title":"DistMesh.element_volumes","text":"element_volumes(m::DMesh)\n\nReturn a vector of volumes (or areas) for every element in the mesh.\n\n\n\n\n\n","category":"function"},{"location":"api/#DistMesh.element_qualities","page":"API Reference","title":"DistMesh.element_qualities","text":"element_qualities(m::DMesh, quality_func=element_quality)\n\nReturn a vector of quality metrics for every element in the mesh.\n\n\n\n\n\n","category":"function"},{"location":"api/#DistMesh.cleanup_mesh","page":"API Reference","title":"DistMesh.cleanup_mesh","text":"cleanup_mesh(msh::DMesh) -> (msh::DMesh, ix::Vector{Int})\n\nRemove duplicate nodes from the mesh msh and re-index the connectivity.\n\nThis function identifies nodes that are coincident (or within a very small tolerance relative to the mesh size)  and merges them. This is useful after mesh generation or modification operations that might create  overlapping vertices.\n\nArguments\n\nmsh::DMesh: The input mesh containing nodes p and connectivity t.\n\nReturns\n\nA NamedTuple (msh, ix) where:\n\nmsh: The cleaned DMesh with duplicate nodes removed.\nix: An index vector mapping the new nodes to the old nodes (i.e., new_p = old_p[ix]).\n\nExample\n\nclean_msh, = cleanup_mesh(dirty_msh)  # Ignoring the index output (ix)\n\n\n\n\n\n\n","category":"function"},{"location":"examples/#Examples","page":"Examples","title":"Examples","text":"A collection of 2D meshing examples. Note that all the codes are available in the examples directory.","category":"section"},{"location":"examples/#Polygon-Mesh","page":"Examples","title":"Polygon Mesh","text":"using DistMesh\nusing CairoMakie\nCairoMakie.activate!(type=\"png\", px_per_unit=1.0); # hide\nnothing #hide\n\nFirst, define the vertices of the polygon as a list of points (tuples)\n\npv = [(-0.4, -0.5), (0.4, -0.2), (0.4, -0.7), (1.5, -0.4),\n      (0.9, 0.1), (1.6, 0.8), (0.5, 0.5), (0.2, 1.0),\n      (0.1, 0.4), (-0.7, 0.7), (-0.4, -0.5)];\nnothing #hide\n\nNext, use the dpoly function and these vertices to define the distance function\n\nfd(p) = dpoly(p, pv)\n\nWe use a uniform mesh size function, with a given desired edge length\n\nhmin = 0.15\nfh = huniform\n\nDistMesh also needs a bounding box, which must enclose the polygon\n\nbbox = ((-1,-1), (2,1))\n\nSharp corners have to be provided in the pfix argument\n\npfix = pv\n\nGenerate the mesh\n\nmsh = distmesh2d(fd, fh, hmin, bbox, pfix)\n\nFinally, plot the resulting mesh\n\nplot(msh)","category":"section"},{"location":"examples/#NACA-Airfoil-Mesh","page":"Examples","title":"NACA Airfoil Mesh","text":"This example shows how to generate a mesh around a NACA0012 airfoil.\n\nFirst, load the required packages and define a convenient short-hand for static 2D points.\n\nusing DistMesh\nusing CairoMakie\nCairoMakie.activate!(type=\"png\", px_per_unit=1.0); # hide\nusing StaticArrays\n\nconst Point2d = SVector{2, Float64}\n\nFirst, we define the size function for the NACA airfoil. It consists of the minimum of several point sources and constants:\n\nA point source at the tip of the airfoil, with size hlead\nA point source at the trailing edge of the airfoil, with size htrail\nA maximum element size in the entire domain hmax\n\nfunction hnaca(p; hlead=0.01, htrail=0.04, hmax=2.0)\n    minimum((hlead + 0.3 * dcircle(p, c=(0, 0), r=0),\n        htrail + 0.3 * dcircle(p, c=(1, 0), r=0),\n        hmax))\nend\n\nNext, we define the fix points. This could be as simple as just the trailing edge at (1,0). However, the mesh quality is improved by providing several points along the surface, spread out consistently with the size function above. Therefore, this function also needs the edge length htrail from before. We also add the symmetry point (0,0).\n\nfunction fixnaca(; htrail=0.04)\n    a0, a14... = naca_coeffs\n    fixx = 1 .- htrail * cumsum(1.3 .^ (0:4))\n    fixy = a0 * sqrt.(fixx) .+ fixx .^ (1:4)' * a14\n    fix = vcat(Point2d[(0,0),(1,0)], [ Point2d[(x,y),(x,-y)] for (x,y) in zip(fixx,fixy) ]...)\nend\n\nFinally, we can define a function for generating the arguments to distmesh2d for generating the NACA mesh. The parameters are the sizes from before, as well as a center point (circx,0) and a radius for the far-field circle boundary.\n\nfunction dm_naca(; hlead=0.01, htrail=0.04, hmax=2.0, circx=2.0, circr=4.0)\n    # Distance function: Difference between the outer circle and the NACA airfoil\n    dfcn(p) = ddiff(dcircle(p, c=(circx, 0), r=circr), dnaca(p))\n\n    # Size function: Given by `hnaca` above\n    hfcn(p) = hnaca(p; hlead=hlead, htrail=htrail, hmax=hmax)\n\n    # Fix points: Add symmetry points for the circle plus the ones from `fixnaca`\n    fix = Point2d[(1,0),(0,1),(-1,0),(0,-1)] .* circr .+ Point2d[(circx,0)]\n    fix = vcat(fix, fixnaca(htrail=htrail))\n\n    # Bounding box: Determined by the far-field circle\n    bbox = [(circx - circr, -circr), (circx + circr, circr)]\n\n    # The `hmin` parameter needs to be the smallest element size in the domain\n    hmin = minimum((hlead, htrail, hmax))\n\n    dfcn, hfcn, hmin, bbox, fix\nend\n\nNow we can generate and plot the default mesh\n\nmsh = distmesh2d(dm_naca()...)\nplot(msh)\n\nWe can modify the mesh, e.g. by shrinking the farfield circle\n\nmsh = distmesh2d(dm_naca(circx=1, circr=1.5)...)\nplot(msh)\n\nFinally, we can increase the element sizes at the sources\n\nmsh = distmesh2d(dm_naca(circx=1, circr=1.5, hlead=0.05, htrail=0.1)...)\nplot(msh)","category":"section"},{"location":"#DistMesh.jl","page":"Home","title":"DistMesh.jl","text":"DistMesh.jl is a Julia package for generating unstructured triangular and tetrahedral meshes. It uses Signed Distance Functions (SDFs) to define geometries, enabling the generation of high-quality, isotropic meshes for complex shapes defined by simple mathematical functions.\n\n","category":"section"},{"location":"#Installation","page":"Home","title":"Installation","text":"using Pkg\nPkg.add(\"DistMesh\")\n\n\n","category":"section"},{"location":"#Introduction","page":"Home","title":"Introduction","text":"","category":"section"},{"location":"#A-Simple-Example-Mesh","page":"Home","title":"A Simple Example Mesh","text":"The primary entry point for 2D meshing is distmesh2d. It generates a mesh based on:\n\nA distance function fd(p) (negative inside, positive outside). In this example, we represent the unit circle by d(xy) = sqrtx^2+y^2 - 1.\nA relative size function fh(p). For a uniform mesh, we can simply set h(xy)=1.\nAn initial element edge length h0. Since our size function is uniform, this will also be roughly the final size of the generated elements.\nA bounding box bbox for the domain. For the unit circle, we use the coordinates ((-1,-1), (1,1)).\n\nThe code below demonstrates how to implement this using DistMesh in Julia.\n\nusing DistMesh\nusing CairoMakie             # or Plots, or GLMakie (optional)\nCairoMakie.activate!(type=\"png\", px_per_unit=1.0) # hide\n\nfd(p) = sqrt(sum(p.^2)) - 1  # or dcircle(p) - unit circle geometry\nfh(p) = 1.0                  # or huniform(p) - uniform size function\nhmin  = 0.2                  # initial edge lengths\nbbox  = ((-1,-1), (1,1))     # bounding box for unit circle\n\nmsh = distmesh2d(fd, fh, hmin, bbox)\n\n\nThe resulting mesh can be visualized with the plot command.\n\nplot(msh)\n","category":"section"},{"location":"#Accessing-the-generated-mesh","page":"Home","title":"Accessing the generated mesh","text":"The msh object contains the node coordinates p and the triangle indices t, stored as vectors of static vectors (for efficiency).\n\n# Access the nodes and connectivity as vectors of static vectors\np, t = msh\np[1:3] # First 3 nodes\n\n\nt[1:3] # First 3 triangles (indices)\n\n\np[t[1]] # x,y-coordinates of the first triangle\n\n\nIf you prefer a matrix-based representation (similar to the original MATLAB DistMesh, except transposed), the utility function as_arrays creates a zero-allocation view for this. Note that if you modify these matrices, the original versions in msh will also be changed!\n\n# Access the nodes and connectivity as matrices\np_mat, t_mat = as_arrays(msh)\np_mat[:, 1:3] # First 3 nodes\n\n\nt_mat[:, 1:3] # First 3 triangles (indices)\n\n\np_mat[:, t_mat[:, 1]] # x,y-coordinates of the first triangle\n\n\nIf you want separate re-allocated versions of these matrices, use collect.","category":"section"},{"location":"#Fixed-points","page":"Home","title":"Fixed points","text":"An optional argument to distmesh2d is pfix - a vector of frozen points that are forced to be part of the generated mesh. These are typically required for boundaries with sharp corners, since the implicit geometry representation as a signed distance function does not explicitly provide them.\n\nHere is a simple example of a mesh of a rectangle, where we include the four corner points in pfix.\n\nfd(p) = drectangle(p, 0, 1, 0, 1)\npfix = ((0,0), (1,0), (0,1), (1,1))\nmsh = distmesh2d(fd, huniform, 0.1, ((0,0), (1,1)), pfix)\nplot(msh)\n","category":"section"},{"location":"#Implicit-Geometry-vs-Distance-Function","page":"Home","title":"Implicit Geometry vs Distance Function","text":"Although the original version of DistMesh required actual signed distance functions for the geometry, this condition was relaxed in later versions. The algorithm actually accepts any smooth function with an implicitly defined zero level-set.\n\nThis can be very convenient when defining non-trivial geometries. For example, an ellipse with semi-axes 2 and 1 can now be represented as the zero level-set of d(xy)=(x2)^2 + (y1)^2 - 1. Note that this is not the actual Euclidean distance function for the ellipse.\n\nfd(p) = (p[1]/2)^2 + (p[2]/1)^2 - 1\nbbox = ((-2,-1), (2,1))\nmsh = distmesh2d(fd, huniform, 0.2, bbox)\nplot(msh)\n","category":"section"},{"location":"#Non-uniform-size-function","page":"Home","title":"Non-uniform size function","text":"For non-uniform element sizes, we provide a (relative) size function h(xy). In general, it is best to make this an absolute size function that gives the actual desired edge lengths at point . To achieve this, you set the initial edge lengths hmin to the smallest value of h(xy) in the domain.\n\nFor example, to set the element sizes to  at a source and let the element sizes increase linearly away from the source, we use a size function h(xy)=h_mathrmmin + 03d(xy) where d(xy) is the distance function of the source.\n\n# Point source\nhmin = 0.01\nfh(p) = hmin + 0.3 * dcircle(p, r=0)\nmsh = distmesh2d(dcircle, fh, hmin, ((-1,-1), (1,1)))\nplot(msh)\n\n\nMultiple size function sources can be combined using the min function:\n\n# Point and line sources\nfd(p) = drectangle(p, 0, 1, 0, 1)\nfh(p) = min(min(0.01 + 0.3*abs(dcircle(p, r=0)),\n                0.025 + 0.3*abs(dpoly(p, [(0.3,0.7), (0.7,0.5)]))),\n            0.15)\n# Note: we explicitly add corners to pfix for the rectangle\npfix = ((0,0), (1,0), (0,1), (1,1))\nmsh = distmesh2d(fd, fh, 0.01, ((0,0), (1,1)), pfix)\nplot(msh)\n","category":"section"},{"location":"#Randomness-and-Reproducibility","page":"Home","title":"Randomness and Reproducibility","text":"The DistMesh algorithm is notoriously chaotic, or sensitive to initial conditions. This means that very small perturbations in the mesh calculations can grow to large changes in the mesh (resulting in completely different meshes).\n\nHowever, running on the same deterministic computer, if you repeat a distmesh2d call twice with uniform size functions, it usually gives two identical meshes because it uses a deterministic grid-based initialization:\n\nmsh1 = distmesh2d(dcircle, huniform, 0.2, ((-1,-1), (1,1)))\nmsh2 = distmesh2d(dcircle, huniform, 0.2, ((-1,-1), (1,1)))\nmsh1.p == msh2.p && msh1.t == msh2.t\n\n\nFor non-uniform size functions, DistMesh uses the rand function for the initial point distribution (rejection sampling). This means two meshes with identical inputs will in general not be the same:\n\nfh(p) = 0.01 + 0.3 * dcircle(p, r=0)\nmsh1 = distmesh2d(dcircle, fh, 0.01, ((-1,-1), (1,1)))\n\n\nmsh2 = distmesh2d(dcircle, fh, 0.01, ((-1,-1), (1,1)))\n\n\n# Check if they are identical (likely false)\nmsh1.p == msh2.p && msh1.t == msh2.t\n\n\nMany times this is undesirable (e.g., for regression testing or debugging). You can seed the random number generator to make the meshes identical:\n\nusing Random\nfh(p) = 0.01 + 0.3 * dcircle(p, r=0)\n\nRandom.seed!(1234)\nmsh1 = distmesh2d(dcircle, fh, 0.01, ((-1,-1), (1,1)))\n\n\nNow we generate the second mesh with the same seed:\n\nRandom.seed!(1234)\nmsh2 = distmesh2d(dcircle, fh, 0.01, ((-1,-1), (1,1)))\n\n\nFinally, we verify they are identical:\n\nmsh1.p == msh2.p && msh1.t == msh2.t\n","category":"section"},{"location":"#Save/export-meshes","page":"Home","title":"Save/export meshes","text":"DistMesh does not provide built-in mesh export functionality to external formats. However, it is easy to write specialized routines, e.g., based on text files.\n\nA common format is to have an initial line with metadata (number of nodes and elements), followed by comma-separated rows for node positions and element connectivities:\n\nusing DelimitedFiles\n\nfunction savemesh(msh::DMesh, fname)\n    open(fname, \"w\") do io\n        p, t = as_arrays(msh)\n        println(io, \"$(length(p)) $(length(t)) # nbr_nodes nbr_elems\")\n        writedlm(io, p', ',')\n        writedlm(io, t', ',')\n    end\nend\n\nmsh = distmesh2d(dcircle, huniform, 0.2, ((-1,-1), (1,1)))\nfname = joinpath(tempdir(), \"mesh.dat\")\nsavemesh(msh, fname)\nprintln(\"Mesh saved to file $fname\")\n\n\n","category":"section"},{"location":"#More-about-Distance-Functions","page":"Home","title":"More about Distance Functions","text":"TODO\n\n","category":"section"},{"location":"#More-about-Size-Functions","page":"Home","title":"More about Size Functions","text":"TODO","category":"section"}]
}
